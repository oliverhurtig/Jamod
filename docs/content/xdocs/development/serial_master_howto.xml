<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "document-v12.dtd"><document>   <header>     <title>Serial Master HOW-TO</title>    <version>1.1 (08/06/2004)</version>    <authors>      <person name="Dieter Wimberger" email=" wimpi@users.sourceforge.net "/>    </authors>  </header>   <body>     <section id="About">      <title>About</title>	  <p>	   This document is a tutorial for writing Modbus/Serial Master applications utilizing        the <em>jamod</em> library. It explains the basics and walk's you through        a simple command line Master implementation, that will allow you to read the state        of one or more input registers from a slave on the network.<br/>       If you are new to Modbus, it is highly recommended to first take a look at <link href="../kbase/protocol.html">&quot;Understanding        the Protocol&quot;</link> (especially the section about the Serial implementation) as well as the actual protocol specifications.       </p> 	  <warning>	    You will need the Java Communications API extension (<code>javax.comm</code>) installed to be able to run serial		modbus applications.<br/>	  </warning>	  <note>	   The application build in the tutorial is actually part of the distribution codebase	   (<link href="../api/net/wimpi/modbus/cmd/SerialAITest.html"><code>net.wimpi.modbus.cmd.SerialAITest</code></link>).	  </note>    </section>    <section id="whatismaster">	  <title>What is a Master?</title>	  <p>	    Thinking in terms of the Client-Server network computing paradigm, the Master         application is a <strong>client</strong>. It establishes a <em>connection</em> with	    the slave (i.e. the <strong>server</strong>) and uses this connection for sending	    a <em>Request</em> to the slave, from which a <em>Response</em> will be received.<br/>	    As described in <link href="../kbase/protocol.html"><em>Understanding the Protocol</em></link>, 	    each cycle of <em>Request</em> and <em>Response</em> is called a <em>Transaction</em>.        Figure 1 shows a simple graphical representation of such a cycle:	  </p>      <table>	    <caption>Figure 1: Modbus Transaction</caption>        <tr>           <td><figure src="../images/transaction.png" alt="Modbus Transaction" width="261" height="46"/></td>        </tr>      </table>	  <p>	    In case of the serial implementation, the communication can be point-to-point         (RS232, 422, 485) or on a shared signal cable (RS 485). In both cases there should         be only one master, that acquires data from a source (data acquisition), or writes         data to a sink (device control).<br/>        A possible simple &quot;network setup&quot; for this tutorial is composed of two         nodes, as depicted in Figure 2.	  </p>	  <table>	    <caption>Figure 2: Network Setup</caption>        <tr>           <td><figure src="../images/serialmaster_network_nodal.png" alt="Network setup" width="92" height="155"/></td>        </tr>      </table>	</section>    <section id="whatisinputregister">	  <title>What is an Input Register?</title>	  <p>	    According to the Modbus data model, which is part of the protocol specification         (see section 4.3), an <em>Input Register</em> is a 16 bit word &quot;data item&quot;,         which is usually provided by an I/O system (analog input module). Figure 3 shows         an example with simple switches that are mapped into the slave's process image         in form of discrete inputs. The example master application will be capable of         obtaining the state of these DI's from the slave.	  </p>	  <table>        <caption>Figure 3: Slave with IR's</caption>		<tr>           <td><figure src="../images/serialmaster_procimg_example.png"  alt="Slave with IR's" width="238" height="144"/></td>        </tr>      </table>	  <note>	    Related information is available in <link href="processimage.html"><em>Understanding         the Process Image</em></link>.	  </note>	</section>	<section id="classesofinterest">	  <title>Classes of Interest for the Developer</title>      <p>	    The motivation for creating <em>jamod</em> was to achieve an intuitive and object 		oriented implementation of the protocol, in a way, that there is a natural mapping 		from the domain knowledge (i.e. Modbus protocol) to the abstract class model. 		The important elements in the description above (<code>What is a Master?</code>) have been 		highlighted and the following list represents the mapping between them and the classes from 		<em>jamod</em> that will be needed for a master implementation:	  </p>	  <ul>        <li>		  <em>Connection</em>: <link href="../api/net/wimpi/modbus/net/SerialConnection.html"><code>SerialConnection</code></link>		</li>        <li>		  <em>Transaction</em>: <link href="../api/net/wimpi/modbus/io/ModbusSerialTransaction.html"><code>ModbusSerialTransaction</code></link>		</li>        <li>		  <em>Request</em>: <link href="../api/net/wimpi/modbus/msg/ModbusRequest.html"><code>ModbusRequest</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/msg/ReadInputRegistersRequest.html"><code>ReadInputRegistersRequest</code></link>)		</li>        <li>		  <em>Response</em>: <link href="../api/net/wimpi/modbus/msg/ModbusResponse.html"><code>ModbusResponse</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/msg/ReadInputRegistersResponse.html"><code>ReadInputRegistersResponse</code></link>)		</li>      </ul>    </section>	<section id="implementation">	  <title>Implementation</title>	  <p>	    As the idea is to provide a tutorial in form of a very simple command line example,         it will consist of only one class and most of the work will be done in the entry         method (<code>public static void main(String args[])</code>). This is probably not         the way <em>jamod</em> will be usually employed in OO designs, but we hope 		it serves the demonstrative purpose.	  </p>	  <p>	    Before we start with coding, let's take a look at the simplified interaction diagram         of the application, given as Figure 4. The part most interesting for this tutorial         is colored blue, but note that the diagram also contains a little bit of the things         that happen behind the scenes (i.e. within the <code>Transport</code>, with <code>writeRequest()</code>         and <code>readRequest()</code>), which are there to give a more complete picture.	  </p>	  <table>	    <caption>Figure 4: Simplified Master Interaction Diagram</caption>        <tr>           <td><figure src="../images/serialmaster_sequential.png" alt="Sequential Interaction Diagram" width="509" height="377"/></td>        </tr>      </table>	  <p>	    Now let's start writing code. We need a simple Java application skeleton, with         imports of all <em>jamod</em> packages:	  </p>	  <source>import java.net.*;import java.io.*;import net.wimpi.modbus.*;import net.wimpi.modbus.msg.*;import net.wimpi.modbus.io.*;import net.wimpi.modbus.net.*;import net.wimpi.modbus.util.*; public class SerialAITest {  public static void main(String[] args) {    try {      ...      ...    } catch (Exception ex) {      ex.printStackTrace();    }  }//main  }//class SerialAITest      </source>	  <p>	    Next we add the instances and variables the application will need:	  </p>	  <source>/* The important instances of the classes mentioned before */SerialConnection con = null; //the connectionModbuSerialTransaction trans = null; //the transactionReadInputRegistersRequest req = null; //the requestReadInputRegistersResponse res = null; //the response/* Variables for storing the parameters */String portname= null; //the name of the serial port to be usedint unitid = 0; //the unit identifier we will be talking toint ref = 0; //the reference, where to start reading fromint count = 0; //the count of IR's to readint repeat = 1; //a loop for repeating the transaction	  	  </source>	  <p>	    Next the application needs to read in the parameters:	  </p>	  <ol>        <li>&lt;portname [String]&gt; as <code>String</code> into <code>portname</code></li>        <li>&lt;Unit Address [int8]&gt; as <code>String</code> into <code>unitid</code></li>        <li>&lt;register [int16]&gt; as <code>int</code> into <code>ref</code></li>        <li>&lt;wordcount [int16]&gt; as <code>int</code> into <code>count</code></li>        <li>{&lt;repeat [int]&gt;} as <code>int</code> into <code>repeat</code>, 1 by default (optional)</li>      </ol>	  <source>//1. Setup the parameters	  if (args.length &lt; 4) {  System.exit(1);} else {  try {    portname = args[0];    unitid = Integer.parseInt(args[1]);    ref = Integer.parseInt(args[2]);    count = Integer.parseInt(args[3]);    if (args.length == 5) {      repeat = Integer.parseInt(args[4]);    }  } catch (Exception ex) {    ex.printStackTrace();    System.exit(1);  }}	  </source>	  <p>	    These will be used subsequently to setup the connection and the request. First,         however, we need to set the identifier of the Master on the serial network (in         this case to <code>1</code>), as well as the parameters for the connection:	  </p>	  <source>//2. Set master identifierModbusCoupler.createModbusCoupler(null);ModbusCoupler.getReference().setUnitID(1);	//3. Setup serial parametersSerialParameters params = new SerialParameters();params.setPortName(portname);params.setBaudRate(115200);params.setDatabits(7);params.setParity("None");params.setStopbits(2);  	  </source>	  <note>	    You should adapt the serial parameters to your requirements, which you can do hardcoded or by reading in the parameters		from the commandline or as properties file.	  </note>	  <p>	    Once the parameters are prepared, we can open the connection (in this case the serial port will be openend)		as well as prepare a request and a transaction:	  </p>	  <source>//4. Open the connectioncon = new SerialConnection(params);con.open();//5. Prepare a requestreq = new ReadInputRegistersRequest(ref, count);req.setUnitID(unitid);req.setHeadless();//6. Prepare a transactiontrans = new ModbusSerialTransaction(con);trans.setRequest(req);      </source>	  <p>	    No we are ready for action. The last part is executing the prepared transaction the given (<code>repeat</code>) number		of times and then for cleanup, close the connection:	  </p>	  <source>//7. Execute the transaction repeat timesint k = 0;do {  trans.execute();  res = (ReadInputRegistersResponse) trans.getResponse();  for (int n = 0; n &lt; res.getWordCount(); n++) {    System.out.println("Word " + n + "=" + res.getRegisterValue(n));  }  k++;} while (k &lt; repeat);//8. Close the connectioncon.close();  	  </source>	  <p>	    That's it. This should do the job if the serial connection is established and the parameters are set accordingly 		for Master and Slave.	  </p>	  <note>	    The debug outputs of the library can be activated by passing the property 	    <code>net.wimpi.modbus.debug</code> and allow to see the actually exchanged modbus messages 	    encoded as hex.	  </note>	</section>  </body></document>  