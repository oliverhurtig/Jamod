<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "document-v12.dtd"><document>   <header>     <title>Understanding the Process Image</title>    <version>1.1 (08/06/2004)</version>    <authors>      <person name="Dieter Wimberger" email=" wimpi@users.sourceforge.net "/>    </authors>  </header>   <body>     <section id="About">      <title>About</title>	  <p>	    This document should help the reader to understand the ideas behind the abstraction         of a process image suited for the Modbus basic data types.<br/>      </p>      </section>    <section id="ProcessImage">	  <title>What is a Process Image?</title>      <p>       Lets assume we have a continuous ongoing process and we are using measurements        to observe the process. The measurements will be made at certain points in time,        representing a discretization of the actual measured functions into a sequence        of sets {f(t<sub>i</sub>), g(t<sub>i</sub>), h(t<sub>i</sub>), ...}. Each set        of values should be homogenous in relation to time, i.e. the values should correspond        to one and the same point in time t<sub>i</sub> to be meaningful for observations        (or control) of the process.<br/>       Especially if we have multiple &quot;users&quot; (i.e. corresponding control programs,        network data acquisition, visualization etc.) accessing the data concurrently,        we want to ensure this property. Thus requests are not directly made to corresponding        I/O modules, but rather to a set corresponding to a certain point in time, that        is stored cyclically in a block of memory (usually deploying some kind of synchronization        mechanism for sequential access). This memory stored set of process measurements        (or I/O states) is often called &quot;process image&quot;, as it represents the        state of a process at a certain point of time (respectively in terms of what we        can measure).	 </p>     <section id="ProcessImageModbus">       <title>A Process Image for Modbus</title>	 <p>       As described in <link href="../kbase/protocol.html#DataModel">Understanding the Protocol        - Modbus Data Model</link>, a set of simple data types is defined by the Modbus specification.        The following list presents the abstract models for the different corresponding        types of the data model:	 </p>       <ol>       <li>a <link href="#DI">Digital Input</link> (for a <em>discrete input</em>)</li>       <li>a <link href="#DO">Digital Output</link> (for a <em>discrete output</em> or <em>coil</em>)</li>       <li>an <link href="#IR">Input Register</link> (for an <em>input register</em>)</li>       <li>a <link href="#RE">Register</link> (for a <em>holding register</em>)</li>     </ol>     <p>	   The accessible and modifiable collection of elements which are instances of 1-4        is an abstraction of the idea of a process image, like presented before. All of        these elements are discussed in the following subsections.	 </p>   </section>	<anchor id="DI"/>    <section id="DigitalInput">	  <title>Digital Input</title>	  <p>        Basically represents an abstraction for an input that is fed by a digital sensor         (i.e. 1 or 0, respectively true/false or on/off etc.). Figure 1 presents a possible         symbolic notation and the interface representing the corresponding software model         (<link href="../api/net/wimpi/modbus/procimg/DigitalIn.html"><code>DigitalIn</code></link>).	  </p>	    <table>		  <caption>Figure 1: Digital Input Model</caption>          <tr>             <td><figure src="../images/procimage_digitalin.png" alt="" width="137" height="110"/></td> 		    <td><figure src="../images/discrete_input.png" alt="" width="114" height="24"/></td>           </tr>        </table> 	  <p>        It consists of isSet() and isValid(), latter for checking whether the returned         state of the input is valid.	  	  </p>    </section>	<anchor id="DO"/>	<section id="DigitalOutput">	  <title>Digital Output</title>	  <p>	    Basically represents an abstraction for an I/O connected to a digital actor. It         can be in, as well as switched into, the states on/off (respectively true/false         or 1/0 etc.). Figure 2 presents a possible symbolic notation of the input states         and the interface representing the corresponding software model 		(<link href="../api/net/wimpi/modbus/procimg/DigitalOut.html"><code>DigitalOut</code></link>).	  </p>      <table>	    <caption>Figure 2: Digital Output Model</caption>        <tr>           <td><figure src="../images/procimage_digitalout.png" width="137" alt=""  height="110"/></td>          <td><figure src="../images/discrete_output.png" alt="" width="95" height="55"/></td>        </tr>      </table>      <p>        It consists of isSet(), set(boolean) and isValid(), latter for checking whether         the returned state of the output is valid.	  </p>      </section>	<anchor id="IR"/>    <section id="InputRegister">      <title>Input Register</title>      <p>        Represents an abstraction for an analog input that is fed by an analog sensor.         It can take a range of values, which is basically limited by the number of possible         values for a 16 bit Integer. Figure 3presents a possible symbolic notation and         the interface representing the corresponding software model	    (<link href="../api/net/wimpi/modbus/procimg/InputRegister.html"><code>InputRegister</code></link>).      </p>      <table>	    <caption>Figure 3: Input Register Model</caption>        <tr>           <td><figure src="../images/procimage_inputregister.png" alt="" width="137" height="110"/></td>          <td><figure src="../images/input_register.png" alt="" width="120" height="36"/></td>        </tr>      </table>      <p>        It consists of getValue() and isValid(), latter for checking whether the returned         value of the input is valid.      </p>    </section>	<anchor id="RE"/>	<section id="Register">	  <title>Register</title>      <p>        Represents an abstraction for an analog I/O connected to an analog actor. It can         take and be set a range of values, which is limited by the number of possible         values for a 16 bit Integer. Figure 4 presents a possible symbolic notation and         the interface representing the corresponding software model 		(<link href="../api/net/wimpi/modbus/procimg/Register.html"><code>Register</code></link>).	  </p>      <table>	    <caption>Figure 4: Register Model</caption>        <tr>          <td><figure src="../images/procimage_register.png" alt="" width="137" height="110"/></td>         <td><figure src="../images/holding_register.png" alt="" width="117" height="28"/></td>        </tr>      </table>      <p>        It consists of getValue(), setValue(int) and isValid(), latter for checking whether         the returned value of the I/O is valid.      </p>	</section>  </section>  <anchor id="PIC"/>  <section id="ProcessImageCollection">    <title>ProcessImage - The Collection</title>	<p>      Represents the actual process image, a collection of all instances of the formerly       presented elements (<link href="#DI">DigitalIn</link>, <link href="#DO">DigitalOut</link>	  , <link href="#IR">InputRegister</link>, <link href="#RE">Register</link>). According       to the Modbus specification, the simplest organization of this data in &quot;memory&quot;       for a virtual device which has no real memory limits, are separate blocks for       each data type. The resulting software model 	  (<link href="../api/net/wimpi/modbus/procimg/ProcessImage.html"><code>ProcessImage</code></link>,       and <link href="../api/net/wimpi/modbus/procimg/ProcessImageImplementation.html"><code>ProcessImageImplementation</code></link>)       are presented in Figure 5.	</p>      <table>	  <caption>Figure 5: Process Image Model</caption>      <tr>         <td><figure src="../images/procimage_interface.png" alt="" width="335" height="469"/></td>      </tr>    </table>  </section>  <section id="Implementation">    <title>Example Implementation and Extensibility</title>    <p>      The presented model is definitely kept very simple, but it is extremely powerful.       First, it is possible to simply swap references of two 	  <link href="#PIC"><code>ProcessImage</code></link> instances       cyclically (sequential access can be ensured easily). Alternating, one presents       the snapshot of a given moment in time, while the other is refreshed with new       data. However, if this is not necessary, synchronization mechanisms can be still       deployed at the level of element instances (respectively their implementations).     </p>	<p>	  Second, the generic interface allows generic slave access to the standard Modbus       data types; in a few lines of code you can have your Modbus slave (or server)       up and running.<br/>	  jamod comes with a very simple demonstration implementation. All related classes       are prefixed with <code>Simple</code>:	</p>      <ul>      <li><link href="../api/net/wimpi/modbus/procimg/SimpleDigitalIn.html"><code>SimpleDigitalIn</code></link></li>      <li><link href="../api/net/wimpi/modbus/procimg/SimpleDigitalOut.html"><code>SimpleDigitalOut</code></link></li>      <li><link href="../api/net/wimpi/modbus/procimg/SimpleInputRegister.html"><code>SimpleInputRegister</code></link></li>      <li><link href="../api/net/wimpi/modbus/procimg/SimpleRegister.html"><code>SimpleRegister</code></link></li>      <li><link href="../api/net/wimpi/modbus/procimg/SimpleProcessImage.html"><code>SimpleProcessImage</code></link></li>    </ul>	<p>	  The <code>set</code> methods of these classes are synchronized, which will ensure       atomic access, but not a specific access order. If you are interested in specialized       implementations, I recommend to take a look at:<br/>      <code>Lea, Doug: &quot;Concurrent Programming in Java: Design Principles and Patterns&quot;,       Second Edition, Addison-Wesley, ISBN 0-201-31009-0, November 1999.</code><br/>      The online supplement (which you might want to check out for the code) is available at:<br/>      <link href="http://gee.cs.oswego.edu/dl/cpj">http://gee.cs.oswego.edu/dl/cpj</link>	</p>	<section>	  <title>How to make use of the Model</title>      <p>        The basic idea behind the set of interfaces is to make the developers life more         simple. The following example source will show how to implement a 		<link href="#DI"><code>DigitalIn</code></link>        that returns a random value. From this example and the demonstration example,         you can hopefully infer a more sense making implementation, probably based on         the <em>Java Native Interface (JNI)</em>.      </p>		      <source>package net.wimpi.example;import net.wimpi.modbus.procimg.*;import java.util.Random;public final class RandomDigitalIn    implements DigitalIn { //instance variables private Random m_Random;  /**   * Constructs a new &lt;tt&gt;RandomDigitalIn&lt;/tt&gt;.   */  public RandomDigitalIn() {    m_Random = new Random();  }//constructor  /**   * Constructs a new &lt;tt&gt;RandomDigitalIn&lt;/tt&gt;   * with a given &lt;tt&gt;Random&lt;/tt&gt; instance.   */  public RandomDigitalIn(Random rnd) {    m_Random = rnd;  }//cinstructor(Random)  public final boolean isSet() {    return m_Random.nextBoolean();  }//isSet  public final boolean isValid() {    return true;  }//isValid}//RandomDigitalIn      </source>      <p>        You can use instances of <code>RandomDigitalIn</code> in the examples of the Slave         How-To's to complete the picture of the process image model idea.	  </p>	  </section>  </section>  </body></document>