<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "document-v12.dtd"><document>   <header>     <title>TCP Slave HOW-TO</title>    <version>1.1 (08/06/2004)</version>    <authors>      <person name="Dieter Wimberger" email=" wimpi@users.sourceforge.net "/>    </authors>  </header>   <body>     <section id="About">      <title>About</title>	  <p>	   This document is a tutorial for writing Modbus/TCP Slave applications utilizing        the <em>jamod</em> library. It explains the basics and walk's you through        a simple command line Slave implementation,that will serve the values from a        static process image on Master requests.<br/>       If you are new to Modbus, it is highly recommended to first take a look at <link href="../kbase/protocol.html"><em>Understanding        the Protocol</em></link> (especially the section about the TCP implementation) as well as the actual protocol specifications.       </p> 	  <note>	   The application build in the tutorial is actually part of the distribution codebase	   (<link href="../api/net/wimpi/modbus/cmd/TCPSlaveTest.html"><code>net.wimpi.modbus.cmd.TCPSlaveTest</code></link>).	  </note>    </section>    <section id="whatisslave">	  <title>What is a Slave?</title>	  <p>        Thinking in terms of the Client-Server network computing paradigm, the Slave application         is a Server. It has a <em>Listener</em> for receiving an incoming <em>Request</em>        from the Master application (which indeed is a Client) and sends a corresponding <em>Response</em>,		just as described in <link href="../kbase/protocol.html"><em>Understanding the Protocol</em></link>.      </p>	 <p>       The simple network setup for this tutorial is composed of two nodes, as depicted in Figure 1.	 </p>	 <table>	    <caption>Figure 1: Network Setup</caption>        <tr>           <td><figure src="../images/tcpmaster_network_nodal.png" alt="Network setup" width="98" height="177"/></td>        </tr>      </table>	  <p>	    The implementation from the <em>jamod</em> library will automagically construct         the actual responses for requests related to the standard Modbus data model, according         to the contents of the actually set <em>Process Image</em>.<br/>		The reference to the actual <em>Process Image</em> is stored in the <em>Modbus Coupler</em> a singleton		instance accessible throughout the VM.	  </p>    </section>	<section id="whatisprocessimage">	  <title>What is a Process Image?</title>	  <p>	    A process image is basically a collection of <em>Discrete Inputs</em>, <em>Discrete Outputs (Coils)</em>,         <em>Input Registers</em> and <em>Registers</em>.<br/>	    Please refer to <link href="processimage.html"><em>Understanding the Process Image</em></link> for more information.	  </p>	</section>	<section id="classesofinterest">	  <title>Classes of Interest for the Developer</title>	  <p>	    The motivation for creating <em>jamod</em> was to achieve an intuitive and object 		oriented implementation of the Modbus protocol, in a way, that there is a natural mapping 		from the domain knowledge (i.e. Modbus protocol) to the abstract class model. <br/>		The important elements in the description above (<code>What is a Slave?</code>) have been 		highlighted and the following list represents the mapping between them and the classes from 		<em>jamod</em> that will be needed for a slave implementation:	  </p>      <ul>	    <li>		  <em>Listener</em>: <link href="../api/net/wimpi/modbus/net/ModbusTCPListener.html"><code>ModbusTCPListener</code></link>		</li>        <li>		  <em>Process Image</em>: <link href="../api/net/wimpi/modbus/procimg/ProcessImage.html"><code>ProcessImage</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/procimg/SimpleProcessImage.html"><code>SimpleProcessImage</code></link>)		</li>        <li>		  <em>Discrete Inputs</em>: <link href="../api/net/wimpi/modbus/procimg/DigitalIn.html"><code>DigitalIn</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/procimg/SimpleDigitalIn.html"><code>SimpleDigitalIn</code></link>)		</li>        <li>		  <em>Discrete Outputs</em>: <link href="../api/net/wimpi/modbus/procimg/SimpleDigitalOut.html"><code>DigitalOut</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/procimg/SimpleDigitalOut.html"><code>SimpleDigitalOut</code></link>)		</li>        <li>		  <em>Input Registers</em>: <link href="../api/net/wimpi/modbus/procimg/InputRegister.html"><code>InputRegister</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/procimg/SimpleInputRegister.html"><code>SimpleInputRegister</code></link>)		</li>        <li>		  <em>Registers</em>: <link href="../api/net/wimpi/modbus/procimg/Register.html"><code>Register</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/procimg/SimpleRegister.html"><code>SimpleRegister</code></link>)		</li>        <li>		  <em>Modbus Coupler</em>: <link href="../api/net/wimpi/modbus/ModbusCoupler.html"><code>ModbusCoupler</code></link>		</li>      </ul>    </section>	<section id="implementation">	  <title>Implementation</title>	  <p>	    As the idea is to provide a tutorial in form of a very simple command line example,         it will consist of only one class and most of the work will be done in the entry         method (<code>public static void main(String args[])</code>). This is probably not         the way <em>jamod</em> will be usually employed in OO designs, but we hope 		it serves the demonstrative purpose.	  </p>	  <p>	    Now let's start writing code. We need a simple Java application skeleton, with         imports of all <em>jamod</em> packages:	  </p>	  <source>import net.wimpi.modbus.net.*;import net.wimpi.modbus.procimg.*;import net.wimpi.modbus.ModbusCoupler;public class TCPSlaveTest {  public static void main(String[] args) {    try {      ...      ...    } catch (Exception ex) {      ex.printStackTrace();    }  }//main}//class TCPSlaveTest	  	  </source>	  <p>	    Next we add the instances and variables the application will need, acquiring the value of 		the port number from the first commandline parameter if given:	  </p>	  <source>/* The important instances and variables */ModbusTCPListener listener = null;SimpleProcessImage spi = null;int port = Modbus.DEFAULT_PORT;  //1. Set port number from commandline parameter  if(args != null &amp;&amp; args.length ==1) {    port = Integer.parseInt(args[0]);  }	  </source>	  <p>	    Next we will construct the process image and setup the coupler to         hold the reference:	  </p>	  <source>//2. Prepare a process imagespi = new SimpleProcessImage();spi.addDigitalOut(new SimpleDigitalOut(true));spi.addDigitalOut(new SimpleDigitalOut(false));spi.addDigitalIn(new SimpleDigitalIn(false));spi.addDigitalIn(new SimpleDigitalIn(true));spi.addDigitalIn(new SimpleDigitalIn(false));spi.addDigitalIn(new SimpleDigitalIn(true));spi.addRegister(new SimpleRegister(251));spi.addInputRegister(new SimpleInputRegister(45)); //3. Create the coupler holding the image ModbusCoupler.createModbusCoupler(spi);	  	  </source>	  <note>	    It should be relatively easy to create your own classes of process image related instances.		These might even use the Java Native Interface (JNI) to directly access specific hardware,		and expose their state as register, input register, input discrete or coil.	  </note>	  <p>	    The last step is to create a listener with a thread pool size of 3 and start it:	  </p>      <source>//4. Create a listener with 3 threads in poollistener = new ModbusTCPListener(3);listener.setPort(port);listener.start();  	  </source>		  <p>	    That's all, your slave is ready to serve requests.	  </p>	  <warning>	 	The standard port <code>502</code> might need special access rights on some operating 		systems. For tests you might prefer to use some port <code>&gt;1000</code>.	  </warning>	  <p>	    You can test the slave we just created using the master application from the 		<link href="tcp_master_howto.html"><em>TCP Master How-To</em></link>.<br/>		The following is an example output from the slave, given the request from the formerly		mentioned TCP Master How-To.	  </p>	  <source>Fangorn:~/development/java/jamod wimpi$ java -Dnet.wimpi.modbus.debug=true \  -cp build/classes net.wimpi.modbus.cmd.TCPSlaveTest 5555jModbus Modbus Slave (Server)Listening...Listenening to ServerSocket[addr=localhost/127.0.0.1,port=0,localport=5555](Port 5555)Making new connection Socket[addr=/127.0.0.1,port=58379,localport=5555]Request:00 00 00 00 00 06 00 02 00 00 00 04 Response:00 00 00 00 00 04 00 02 01 50 Request:00 01 00 00 00 06 00 02 00 00 00 04 Response:00 01 00 00 00 04 00 02 01 50 Request:00 02 00 00 00 06 00 02 00 00 00 04 Response:00 02 00 00 00 04 00 02 01 50 	  </source>	  <note>	    The debug outputs of the library can be activated by passing the property 	    <code>net.wimpi.modbus.debug</code> and allow to see the actually exchanged modbus messages 	    encoded as hex.	  </note>	</section>   </body></document>