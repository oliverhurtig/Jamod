<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "document-v12.dtd"><document>   <header>     <title>UDP Master HOW-TO</title>    <version>1.1 (08/06/2004)</version>    <authors>      <person name="Dieter Wimberger" email=" wimpi@users.sourceforge.net "/>    </authors>  </header>   <body>     <section id="About">      <title>About</title>	  <p>	   This document is a tutorial for writing Modbus/UDP Master applications utilizing        the <em>jamod</em> library. It explains the basics and walk's you through        a simple command line Master implementation, that will allow you to read that will 	   allow you to read the state of one or more discrete input's from a slave on the network.<br/>	   If you are new to Modbus, it is highly recommended to first take a look at 	   <link href="../kbase/protocol.html"><em>Understanding the Protocol</em></link> 	   as well as <link href="../kbase/modbus_udp.html">the actual protocol specification</link>.       </p>	  <note>	   The application build in the tutorial is actually part of the distribution codebase	   (<link href="../api/net/wimpi/modbus/cmd/UDPDITest.html"><code>net.wimpi.modbus.cmd.UDPDITest</code></link>).	  </note>    </section>    <section id="whatismaster">	  <title>What is a Master?</title>	  <p>	    Thinking in terms of the Client-Server network computing paradigm, the Master         application is a <strong>client</strong>. It establishes a <em>connection</em> with	    the slave (i.e. the <strong>server</strong>) and uses this connection for sending	    a <em>Request</em> to the slave, from which a <em>Response</em> will be received.<br/>	    As described in <link href="../kbase/protocol.html"><em>Understanding the Protocol</em></link>, 	    each cycle of <em>Request</em> and <em>Response</em> is called a <em>Transaction</em>.        Figure 1 shows a simple graphical representation of such a cycle:	  </p>      <table>	    <caption>Figure 1: Modbus Transaction</caption>        <tr>           <td><figure src="../images/transaction.png" alt="Modbus Transaction" width="261" height="46"/></td>        </tr>      </table>	  <p>	    The master can pull or poll (repeatedly) data from a source (data acquisition),         as well as control a device. In the latter case it is often recommended to understand         the mode of operation of the slave device. Industrial remote I/O's for example         might have a mechanism (i.e. a watchdog) to ensure predictable behavior when the         communication with the master is lost. Thus ensure to study the documentation         of the particular device you are working with.<br/>        The simple<em>network setup</em> for this tutorial is composed of two nodes,         as depicted in Figure 2.	  </p>	  <table>	    <caption>Figure 2: Network Setup</caption>        <tr>           <td><figure src="../images/udpmaster_network_nodal.png" alt="Network setup" width="121" height="205"/></td>        </tr>      </table>	</section>    <section id="whatisdiscreteinput">	  <title>What is a Discrete Input?</title>	  <p>	    According to the Modbus data model, which is part of the protocol specification         (see section 4.3) a <em>Discrete Input</em> is a single bit (i.e. 0 or 1, false         or true), read-only &quot;data item&quot;, which is usually provided by an I/O         system. Figure 3 shows an example with simple switches that are mapped into the         slave's process image in form of discrete inputs. The example master application         will be capable of obtaining the state of these DI's from the slave.	  </p>	  <table>        <caption>Figure 3: Slave with DI's</caption>		<tr>           <td><figure src="../images/udpmaster_procimg_example.png"  alt="Slave with DI's" width="193" height="157"/></td>        </tr>      </table>	  <note>	    Related information is available in <link href="processimage.html"><em>Understanding         the Process Image</em></link>.	  </note>	</section>	<section id="classesofinterest">	  <title>Classes of Interest for the Developer</title>      <p>	    The motivation for creating <em>jamod</em> was to achieve an intuitive and object 		oriented implementation of the protocol, in a way, that there is a natural mapping 		from the domain knowledge (i.e. Modbus protocol) to the abstract class model. 		The important elements in the description above (<code>What is a Master?</code>) have been 		highlighted and the following list represents the mapping between them and the classes from 		<em>jamod</em> that will be needed for a master implementation:	  </p>	  <ul>	    <li>		  <em>Connection</em>: <link href="../api/net/wimpi/modbus/net/UDPMasterConnection.html"><code>UDPMasterConnection</code></link>		</li>        <li>		  <em>Transaction</em>: <link href="../api/net/wimpi/modbus/io/ModbusUDPTransaction.html"><code>ModbusUDPTransaction</code></link>		</li>        <li>		  <em>Request</em>: <link href="../api/net/wimpi/modbus/msg/ModbusRequest.html"><code>ModbusRequest</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/msg/ReadInputDiscretesRequest.html"><code>ReadInputDiscretesRequest</code></link>)		</li>        <li>		  <em>Response</em>: <link href="../api/net/wimpi/modbus/msg/ModbusResponse.html"><code>ModbusResponse</code></link>           (respectively it's direct known subclass <link href="../api/net/wimpi/modbus/msg/ReadInputDiscretesResponse.html"><code>ReadInputDiscretesResponse</code></link>)		</li>      </ul>    </section>	<section id="implementation">	  <title>Implementation</title>	  <p>	    As the idea is to provide a tutorial in form of a very simple command line example,         it will consist of only one class and most of the work will be done in the entry         method (<code>public static void main(String args[])</code>). This is probably not         the way <em>jamod</em> will be usually employed in OO designs, but we hope 		it serves the demonstrative purpose.	  </p>	  <p>	    Before we start with coding, let's take a look at the simplified interaction diagram         of the application, given as Figure 4. The part most interesting for this tutorial         is colored blue, but note that the diagram also contains a little bit of the things         that happen behind the scenes (i.e. within the <code>Transport</code>, with <code>writeRequest()</code>         and <code>readRequest()</code>), which are there to give a more complete picture.	  </p>	  <table>	    <caption>Figure 4: Simplified Master Interaction Diagram</caption>        <tr>           <td><figure src="../images/udpmaster_sequential.png" alt="Sequential Interaction Diagram" width="516" height="385"/></td>        </tr>      </table>	  <p>	    Now let's start writing code. We need a simple Java application skeleton, with         imports of all <em>jamod</em> packages:	  </p>	  <source>import java.net.*;import java.io.*;import net.wimpi.modbus.*;import net.wimpi.modbus.msg.*;import net.wimpi.modbus.io.*;import net.wimpi.modbus.net.*;import net.wimpi.modbus.util.*; public class UDPDITest {  public static void main(String[] args) {    try {      ...      ...    } catch (Exception ex) {      ex.printStackTrace();    }  }//main  }//class UDPDITest      </source>	  <p>	    Next we add the instances and variables the application will need:	  </p>	  <source>/* The important instances of the classes mentioned before */UDPMasterConnection con = null; //the connectionModbusUDPTransaction trans = null; //the transactionReadInputDiscretesRequest req = null; //the requestReadInputDiscretesResponse res = null; //the response/* Variables for storing the parameters */InetAddress addr = null; //the slave's addressint port = Modbus.DEFAULT_PORT;int ref = 0; //the reference; offset where to start reading fromint count = 0; //the number of DI's to readint repeat = 1; //a loop for repeating the transaction	  </source>	  <p>	    Next the application needs to read in the parameters:	  </p>	  <ol>        <li>		  &lt;address [String]&gt; as <code>InetAddress</code> into <code>addr</code><br/>		  optionally the port might be added to the address as :&lt;port&gt;, and read into		  <code>port</code>.		</li>        <li>&lt;register [int16]&gt; as <code>int</code> into <code>ref</code></li>        <li>&lt;bitcount [int16]&gt; as <code>int</code> into <code>count</code></li>        <li>{&lt;repeat [int]&gt;} as <code>int</code> into <code>repeat</code>, 1 by default (optional)</li>      </ol>	  <source>//1. Setup the parametersif (args.length &lt; 3) {  System.exit(1);} else {  try {    String astr = args[0];    int idx = astr.indexOf(':');    if(idx &gt; 0) {      port = Integer.parseInt(astr.substring(idx+1));      astr = astr.substring(0,idx);    }    addr = InetAddress.getByName(astr);    ref = Integer.decode(args[1]).intValue();    count = Integer.decode(args[2]).intValue();    if (args.length == 4) {      repeat = Integer.parseInt(args[3]);    }  } catch (Exception ex) {    ex.printStackTrace();    System.exit(1);  }}	  </source>	  <p>	    These will be used subsequently to setup and open the connection as well as prepare a request		and a transaction:	  </p>	  <source>//2. Open the connectioncon = new UDPMasterConnection(addr);con.setPort(port);con.connect();//3. Prepare the requestreq = new ReadInputDiscretesRequest(ref, count);//4. Prepare the transactiontrans = new ModbusUDPTransaction(con);trans.setRequest(req);	  </source>	  	  <p>	    No we are ready for action. The last part is executing the prepared transaction the given (<code>repeat</code>) number		of times and then for cleanup, close the connection:	  </p>	  <source>//5. Execute the transaction repeat timesint k = 0;do {  trans.execute();  res = (ReadInputDiscretesResponse) trans.getResponse();  System.out.println("Digital Inputs Status=" + res.getDiscretes().toString());  k++;} while (k &lt; repeat);//6. Close the connectioncon.close();	  </source>	  <p>	    That's all. Pretty simple no?<br/>		The following is an example output with (debug enabled) of the application run against a test slave:	  </p>	  <source>Fangorn:~/development/java/jamod wimpi$ java -Dnet.wimpi.modbus.debug=true \  -cp build/classes net.wimpi.modbus.cmd.UDPDITest Fangorn.local.:5555 0 4 3UDPMasterTerminal::activate()::laddr=:localhost/127.0.0.1:lport=5000UDPMasterTerminal::haveSocket():java.net.DatagramSocket@a457b6UDPMasterTerminal::laddr=:localhost/127.0.0.1:lport=5000UDPMasterTerminal::raddr=:localhost/127.0.0.1:rport=5555UDPMasterTerminal::activatedRequest: 00 00 00 00 00 06 00 02 00 00 00 04 Response: 00 00 00 00 00 04 00 02 01 50 Digital Inputs Status=00001010 Response: 00 01 00 00 00 04 00 02 01 50 Digital Inputs Status=00001010 Response: 00 02 00 00 00 04 00 02 01 50 Digital Inputs Status=00001010 UDPMasterTerminal::deactivate()	  </source>	  <note>	  The debug outputs of the library can be activated by passing the property 	  <code>net.wimpi.modbus.debug</code> and allow to see the actually exchanged modbus messages 	  encoded as hex.	  </note>	</section>  </body></document>