<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "document-v12.dtd"><document>   <header>     <title>Understanding the Modbus Protocol</title>    <version>1.1 (08/06/2004)</version>    <authors>      <person name="Dieter Wimberger" email="wimpi@users.sourceforge.net"/>    </authors>  </header>   <body>    <section id="About">      <title>About</title>	  <p>	    This document introduces the reader to the Modbus protocol. It presents a basic         protocol description and discusses the serial and the TCP based implementations.      </p>      </section>	<section id="basics">	  <title>Modbus Protocol Basics</title>      <p>	    Basically Modbus is an application layer protocol (see Figure 1) for communication         between devices, mainly to exchange data typical for the field of automation.	  </p>	  <table>	    <caption>Figure 1: ISO/OSI Context</caption>        <tr>           <td><figure src="../images/modbus_vs_iso.png" alt="Modbus in the ISO/OSI Schema" width="221" height="203"/></td>        </tr>      </table>	  <p>	    At this level Modbus is a stateless client-server protocol (e.g. much like HTTP),         based on <em>transactions</em>, which consist of a <em>request</em> (issued by the         client) and a <em>response</em> (issued by the server). In the field where this         protocol is usually applied, there exists a concept that is one of the possible         schemas governing the lower level communication behavior on a network using a         shared signal cable: Master-Slave. To prevent confusion, the following directed         relations describe Master-Slave in terms of the Client-Server paradigm: 	  </p>	  <ul>        <li>the Master <strong>is a</strong> Client</li>        <li>the Slave <strong>is a</strong> Server</li>      </ul>	  <p>	    A transaction and it's context is visualized in Figure 2.	  </p>      <table>	    <caption>Figure 2: Modbus Transaction</caption>        <tr>           <td><figure src="../images/transaction.png" alt="Modbus Transaction" width="261" height="46"/></td>        </tr>      </table>	  <p>	    The stateless communication is based on a simple package, that is called Protocol         Data Unit (PDU). The protocol specification defines three types of PDU's: 	  </p>	  <ul>        <li><strong>Request PDU</strong>, consisting of:           <ol>            <li>a code specifying a function (<em>Function Code</em>, 1 byte)</li>            <li>and function specific data (<em>Function Data</em>, varying number of bytes)</li>          </ol>        </li>        <li><strong>Response PDU</strong>, consisting of:           <ol>            <li>the function code corresponding to the request (<em>Function Code</em>, 1 byte)</li>            <li>and response specific data (<em>Response Data</em>, varying number of bytes)</li>          </ol>        </li>        <li><strong>Exception Response PDU</strong>, consisting of:           <ol>            <li>the function code corresponding to the request + 0x80 (128), (<em>Error Code</em>, 1 byte)</li>            <li>and a code specifying the exception (<em>Exception Code</em>, 1 byte)</li>          </ol>        </li>        </ul>	  <p>	    Figure 3 presents a visualization of these packages.	  </p>      <table>	    <caption>Figure 3: Modbus Protocol Data Units (PDU)</caption>        <tr>           <td><figure src="../images/modbus_pdu.png" alt="Modbus PDU's" width="227" height="163"/></td>        </tr>      </table>	  <section id="sub_functions">	    <title>Modbus Functions</title>		<p>		  The specification defines a certain number of functions, each of which is assigned           a specific function code. These are in the range 1-127 (decimal), as 129<sub>(1+128)</sub>-           255<sub>(127+128)</sub> represents the range of error codes.           While the first published version of the specification defined different classes           of functions (e.g. Class 0, Class 1, Class 2), the newly released specification           (from http://www.modbus.org; see <link href="../kbase/index.html">Knowledge Base Index</link>) defines           categories of function codes: 		</p>		<ul>          <li><strong>Public</strong><br/>            Are guaranteed to be unique and specify well defined functions that are publicly             documented. These are validated by the community and a conformance test exists.	      </li>          <li><strong>User-Defined</strong><br/>            Are available for user-defined functions, thus their codes might not be unique.             The specification defines the code ranges 65-72 and 100-110 for user-defined             functions.	      </li>          <li><strong>Reserved</strong><br/>            These are currently used by some companies for legacy products and are not             available for public use (these are not discussed any further in the specification).	      </li>        </ul>		<p>          The documentation for a function consists of:		</p>        <ol>          <li>		    a description of the function (i.e. what it is good for), it's parameters             and return values (including possible exceptions).	      </li>          <li>the assigned <em>Function Code</em></li>          <li>the <em>Request PDU</em></li>          <li>the <em>Response PDU</em> </li>          <li>the <em>Exception Response PDU</em></li>        </ol>		<p>		  The specification further documents defined and assigned <strong>public</strong> functions.		</p>	  </section>	  <section id="sub_exceptions">	    <title>Exceptions</title>		<p>		  In certain cases, the response from a slave will be an exception. The primary           identification of an exception response is the error code (function code + 128),           which is further specified by the exception code. Assigned codes and descriptions           can be found in the specification.		</p>	  </section>	  <section id="sub_datamodel">	    <title>Modbus Data Model</title>		<p>		  The basic public functions have been developed for exchanging data typical for           the field of automation. Table 1 contains the basic Modbus data types defined           by the specification.		</p>		<table>		  <caption>Table 1: Modbus Data Types</caption> 		  <tr>             <th><strong>Name</strong></th>            <th><strong>Type</strong></th>            <th><strong>Access</strong></th>            <th><strong>Visual</strong></th>          </tr>          <tr>             <td>Discrete Input</td>            <td>single bit</td>            <td>read-only</td>            <td><figure src="../images/discrete_input.png" alt="Discrete Input" width="114" height="24"/></td>          </tr>          <tr>             <td>Discrete Output (Coils)</td>            <td>single bit </td>            <td>read-write</td>            <td><figure src="../images/discrete_output.png" alt="Discrete output/Coil" width="95" height="55"/></td>          </tr>          <tr>             <td>Input Registers</td>            <td>16-bit word</td>            <td>read-only</td>            <td><figure src="../images/input_register.png" alt="Input Register" width="120" height="36"/></td>          </tr>          <tr>             <td>Holding Registers (Registers)</td>            <td>16-bit word</td>            <td>read-write</td>            <td><figure src="../images/holding_register.png" alt="(Holding) Register" width="117" height="28"/></td>          </tr>        </table>		<note>		  The specification does not define the ways of organizing the related data in a           device. However, the organization has a direct influence on the addresses used           in basic access functions. (Thus always consult the device's documentation to           learn about addressing in basic access functions!)		</note>	  </section>	</section>    <section id="implementations">	  <title>Modbus Implementations</title>	  <p>	    Basically Modbus has been implemented and used over all types of physical links (wire, fiber and radio) 		and various types of lower level communication stacks. However, we will concentrate on the two basic		types of implementations (which are supported by jamod):	  </p>	  <ol>        <li><strong>Serial</strong>: Asynchronous Master/Slave</li>		<li><strong>IP</strong>: Master/Slave</li>	  </ol>			  <section id="sub_serial">	    <title>Serial Modbus Implementations</title>		<p>          Modbus started it's life in form of an implementation for asynchronous serial           network communication. The application level protocol operates directly on top of 		  a serial interface and serial communication standards. The most common ones (over wire)		  are:		</p>		<ul>		  <li>		    <strong>RS232 (EIA232)</strong>:<br/> see 			<link href="http://www.camiresearch.com/Data_Com_Basics/RS232_standard.html"><em>The RS232 Standard</em></link>		  </li>		  <li>		    <strong>RS422/RS485</strong>:<br/> see			<link href="http://www.hw.cz/english/docs/rs485/rs485.html"><em>Introduction to RS422 and RS485</em></link>		  </li>		</ul>		<p>		  RS232 is used for short distance point-to-point communication,           the same is valid for RS 422, which is a bidirectional extension of RS232 for           industrial environments, that also supports longer distances.<br/>		  RS485 can be used for multipoint communication (i.e. multiple devices connected to the same signal           cable), employing the Master-Slave paradigm (one master and n fixed address slaves).           Figure 4 visualizes the possible network setups.		</p>		<table>		  <caption>Figure 4: Serial Network Architectures</caption>          <tr>             <td><figure src="../images/serial_modbus_netarch.png" alt="Serial Network Architectures" width="397" height="208"/></td>          </tr>        </table>		<p>		  To enable the actual communication for this setups, the implementation extends           the PDU with additional fields, better said, it wraps the PDU into a package           with a <em>header</em> and an <em>error checksum</em> (see Figure 5). The resulting           package is defined by the protocol specification as Application Data Unit (ADU),           <strong>that has a maximum package size of 256 bytes</strong>.		</p>		<note>		   The maximum package size limitation of 256 bytes applies for all existing 		   Modbus protocol implementations!		</note>		<table>		  <caption>Figure 5: Serial ADU</caption>          <tr>             <td><figure src="../images/modbus_serial_adu.png" alt="Modbus Serial ADU" width="351" height="54"/></td>          </tr>        </table>		<p>		  The header is composed of an address field (1 byte) and the tail is an error checksum 		  over the whole package, including the address field (i.e. header). For transmission 		  the Modbus message (i.e. ADU) is placed into a frame that has a known beginning 		  and ending point, allowing detection of the start and the end of a message and 		  thus partial messages. There exist two transmission modes, which differ in encoding, 		  framing and checksum: 		</p>		<ol>          <li><strong>ASCII</strong><br/>            Frames are encoded into two ASCII characters per byte, representing the hexadecimal             notation of the byte (i.e. characters 0&#8211;9, A&#8211;F). The error checksum             is represented by a longitudinal redundancy check (LRC; 1 byte) and messages             start with a colon (':', 0x3A), and end with a carriage return &#8211; line             feed (&quot;CRLF&quot;, 0x0D0A). Pauses of 1 second between characters can             occur.	      </li>          <li><strong>RTU</strong><br/>            Frames are transmitted binary to achieve a higher density. The error checksum             is represented by a cyclic redundancy check (16 bit CRC; 2 byte) and messages             start and end with a silent interval of at least 3.5 character times. This             is most easily implemented as a multiple of character times at the baud rate             that is being used on the network. The maximum pause that may occur between             two bytes is 1.5 character times.	      </li>        </ol>        <p>          jamod is designed to support both transmission modes, using an implementation which		  is based on the javax.comm API. 		</p>		<warning>		  The RTU implementation does only support the Master side. It is working by the 		  <strong>best effort</strong> principle, which means it might not work in a reliable		  way in a low-lantency real-time context.		</warning>		<p>		  It is indeed possible to implement the serial transport based on other serial stack		  implementations (i.e. replacements for the Java Comm API implementation) like for example		  <em>SerialPort</em> (<link href="http://www.sc-systems.com/products/serialport/serialport.htm">		  http://www.sc-systems.com/products/serialport/serialport.htm</link>). According to the product info		  it supports around 20 platforms and it has been successfully used to implement the two 		  serial transmission modes in Java (Master only, see <link href="http://www.focus-sw.com/FTMP_MBJV.html">Field           Talk/Java</link>, a commercial Master protocol pack from Focus Engineering).		</p>	  </section>	  <section id="sub_ip">	    <title>IP based Modbus Implementations</title>	    <p>		  A TCP/IP based Modbus protocol implementation (Modbus/TCP) has been recently committed 		  as an RFC draft to the IETF. It uses the TCP/IP stack for communication 		  (registered port is 502) and extends the PDU with an IP specific header		  (see Figure 6).<br/>		  The possible network setups are not governed by the specification; it is possible 		  to setup multi-master systems or realize bidirectional communication 		  (i.e. have nodes that are master and slave at the same time). However, the user should be		  well aware that there are implications from deviations of the Master/Slave schema.		</p>  		<table>		  <caption>Figure 6: Modbus/TCP ADU</caption>          <tr>            <td><figure src="../images/modbus_tcp_adu.png" alt="Modbus TCP ADU" width="307" height="54"/></td>          </tr>        </table>		<p>	      The IP specific header (called MBAP in the specification) is 7 bytes long and composed 		  of the following fields: 		</p>        <ol>          <li>		    the <em>invocation identification</em> (2 bytes) used for transaction pairing; formerly             called <em>transaction identifier</em>		  </li>          <li>		    the <em>protocol identifier</em> (2 bytes), is 0 for Modbus by default; reserved             for future extensions		  </li>          <li>		    the <em>length</em> (2 bytes), a byte count of all following bytes		  </li>		  <li>		    the <em>unit identifier</em> (1 byte) used to identify a remote unit located             on a non-TCP/IP network		  </li>        </ol>	  </section>	</section>	<section>	  <title>Critical Evaluation of the Specification(s)</title>	  <p>	    There are a few points regarding the specification, which are definitely discussable:	  </p>      <ol>        <li>		  The specification does not present a consistent naming for all of the basic           simple data types. This propagates to the naming of a number basic data access           functions. Probably it would be good to elaborate one consistent naming schema,           to avoid confusion and allow better mind mapping.		</li>        <li>		  The <em>Modbus Encapsulated Interface</em> (MEI) is exposed through a documented           public function, without being further explained. 	    </li>        <li>		  The properties of the protocol are perfectly suited for the use of UDP/IP           as transport layer protocol:           <ol>            <li>it is stateless,</li>            <li>transaction oriented</li>            <li>			  and the package size is limited to 256 bytes, which should be easily               transferable over any IP capable link (including IP over Serial) without               the necessity to split the package.			</li>         </ol>        Especially if a real-time communication has to be achieved, it might be of         interest to investigate in a Modbus/UDP implementation.	  </li>        </ol>	<note>	  For learning more about Modbus/UDP, please see: 	  <link href="modbus_udp.html">Modbus/UDP Specification</link>.	</note>	</section>  </body></document>